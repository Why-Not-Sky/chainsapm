/****************************************************************************************
*
* This code was generated by the Command Creator tool for the ChainsAPM project. 
* If manual changes are made to the code they could be lost.
*
****************************************************************************************/
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ChainsAPM.Commands.Agent {
        public class StringList : Interfaces.ICommand<byte> {

                private Helpers.Fnv1a64 hashhelper;

                public DateTime TimeStamp { get; set; }
                [Flags]
                public enum AttributeFlags {
                        IgnoreGetSet = 1,
                        Private = 4,
                        Protected = 8,
                        Friend = 16,
                        Public = 32
                }

                public List<AttributeFlags> MethodFlags { get; set; }
                public List<System.String> Methods { get; set; }

                public StringList () {

                }

                public StringList (System.Int64 timestamp, List<AttributeFlags> methodflags, List<System.String> methods) {
                        TimeStamp = DateTime.FromFileTimeUtc (timestamp);
                        MethodFlags = methodflags;
                        Methods = methods;
                }

                public string Name {
                        get { return "StringList"; }
                }
                public ushort Code {
                        get { return 0x0000; }
                }
                public string Description {
                        get { return "Update Command Description"; }
                }
                public Type CommandType {
                        get { return typeof (System.String); }
                }
                public Interfaces.ICommand<byte> Decode (ArraySegment<byte> input) {

                        if ( input.Count != 0 ) {
                                Helpers.ArraySegmentStream segstream = new Helpers.ArraySegmentStream (input);
                                int size = segstream.GetInt32 ();
                                if ( input.Count == size ) {
                                        short code = segstream.GetInt16 ();
                                        if ( code == Code ) {
                                                var timestamp = segstream.GetInt64 ();

                                                var numberOfMethodFlags = segstream.GetInt32 ();
                                                var listOfMethodFlags = new List<AttributeFlags> ();
                                                for ( int iMethodFlags = 0; iMethodFlags < numberOfMethodFlags; iMethodFlags++ ) {
                                                        var decodeMethodFlags = (AttributeFlags)segstream.GetInt32 ();
                                                        listOfMethodFlags.Add (decodeMethodFlags);
                                                }

                                                var numberOfMethods = segstream.GetInt32 ();
                                                var listOfMethods = new List<System.String> ();
                                                for ( int iMethods = 0; iMethods < numberOfMethods; iMethods++ ) {
                                                        var stringlenMethods = segstream.GetInt32 ();
                                                        var decodeMethodsHash = segstream.GetInt64 ();
                                                        var decodeMethods = segstream.GetUnicode (stringlenMethods);
                                                        listOfMethods.Add (decodeMethods);
                                                }

                                                var term = segstream.GetInt16 ();

                                                if ( term != 0 ) {
                                                        throw new System.Runtime.Serialization.SerializationException ("Terminator is a non zero value. Please check the incoming byte stream for possible errors.");
                                                }
                                                return new StringList (timestamp, listOfMethodFlags, listOfMethods);
                                        } else {
                                                throw new System.Runtime.Serialization.SerializationException ("Invalid command code detected. Please check the incoming byte stream for possible errors.");
                                        }
                                } else {
                                        throw new System.Runtime.Serialization.SerializationException ("Size of message does not match size of byte stream. Please check the incoming byte stream for possible errors.");
                                }
                        } else {
                                throw new System.Runtime.Serialization.SerializationException ("Size of message is zero. Please check the incoming byte stream for possible errors. ");
                        }
                }
                public byte [] Encode () {
                        int byteSize = 0;
                        byteSize += 4; // Length of Array
                        byteSize += sizeof (Int32) * MethodFlags.Count;
                        byteSize += 4; // Length of Array
                        foreach ( var sItem in Methods ) {
                                byteSize += 4; // Length Bytes
                                byteSize += 4; // Hash Bytes
                                byteSize += sItem.Length; // StringLength Bytes
                        }
                        var buffer = new List<byte> (byteSize);
                        buffer.AddRange (BitConverter.GetBytes (byteSize)); // 4 bytes for size, 2 byte for code, 8 bytes for data, 8 bytes for data, 8 bytes for TS, 2 bytes for term
                        buffer.AddRange (BitConverter.GetBytes (Code));
                        buffer.AddRange (BitConverter.GetBytes (TimeStamp.ToFileTimeUtc ()));

                        buffer.AddRange (BitConverter.GetBytes (MethodFlags.Count)); // Length of Array
                        foreach ( var MethodFlags_item in MethodFlags ) {
                                buffer.AddRange (BitConverter.GetBytes ((int)MethodFlags_item));
                        }


                        buffer.AddRange (BitConverter.GetBytes (Methods.Count)); // Length of Array
                        foreach ( var Methods_item in Methods ) {
                                var sBufferMethods_item = System.Text.UnicodeEncoding.Unicode.GetBytes (Methods_item);
                                buffer.AddRange (BitConverter.GetBytes (sBufferMethods_item.Length));
                                buffer.AddRange (hashhelper.ComputeHash (sBufferMethods_item));
                                buffer.AddRange (sBufferMethods_item);
                        }

                        buffer.AddRange (BitConverter.GetBytes ((short)0));
                        return buffer.ToArray ();
                }
        }

}

